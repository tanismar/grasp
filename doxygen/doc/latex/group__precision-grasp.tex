\section{precision-\/grasp}
\label{group__precision-grasp}\index{precision-\/grasp@{precision-\/grasp}}


A module that, given a 3\+D point cloud representing an object, finds the best triplet to perform a three-\/finger precision grasp successfully.  


A module that, given a 3\+D point cloud representing an object, finds the best triplet to perform a three-\/finger precision grasp successfully. 

For further information\+:

I.\+Gori, U. Pattacini, V. Tikhanoff, G. Metta Three-\/\+Finger Precision Grasp on Incomplete 3\+D Point Clouds. In Proceedings of I\+E\+E\+E International Conference on Robotics and Automation (I\+C\+R\+A), 2014.\hypertarget{group__handIKModule_intro_sec}{}\subsection{Description}\label{group__handIKModule_intro_sec}
This module, given a set of 3\+D points, returns the best triplet of 3\+D points on the basis of stability and feasibility properties. The search over the point cloud is executed by means of a discrete particle swarm optimization algorithm. The triplet is then evaluated by the hand\+I\+K\+Module, which returns a feasible configuration of the hand in terms of joint positions, as well as the position and the orientation of the end-\/effector. This information can successively be fed to a module that actually executes the grasp. These information are also sent to some matlab scripts that are inside the app/matlab folder. This module usually takes the 3\+D point cloud from the object-\/reconstruction module.\hypertarget{group__handIKModule_rpc_port}{}\subsection{Commands\+:}\label{group__handIKModule_rpc_port}
The commands sent as bottles to the module port /$<$mod\+Name$>$/rpc are described in the following\+:

{\bfseries H\+E\+L\+P} ~\newline
format\+: \mbox{[}help\mbox{]} ~\newline
action\+: a list of all the possible commands to send to the rpc port is printed.

{\bfseries S\+E\+T\+\_\+\+V\+I\+S\+U\+A\+L\+I\+Z\+A\+T\+I\+O\+N} ~\newline
format\+: \mbox{[}set visualization param\mbox{]} ~\newline
action\+: if param is set to on, a 3\+D viewer containing the reconstructed point cloud along with the chosen end-\/effector position and orientation is depicted. Otherwise this functionality is disabled.

{\bfseries S\+E\+T\+\_\+\+W\+I\+N\+D\+O\+W} ~\newline
format\+: \mbox{[}set param1 param2\mbox{]} ~\newline
action\+: param1 can be x, y, w or h, and it refers respectively to the x position, the y position, the width and the height of the 3\+D viewer. param2 has to be set to the value that is wanted to assign.

{\bfseries S\+E\+T\+\_\+\+O\+F\+F\+S\+E\+T} ~\newline
format\+: \mbox{[}set param1 x y z\mbox{]} ~\newline
action\+: param1 can be offset\+L, for the left arm, or offset\+R, for the right arm. It sets an offset on the corresponding arm (represented by x, y and z), in case there is some error in the mapping between the eye and the arm.

{\bfseries S\+E\+T\+\_\+\+F\+I\+L\+T\+E\+R} ~\newline
format\+: \mbox{[}set filter param\mbox{]} ~\newline
action\+: param can be set to on or off. It is usually set to on, as the stereo vision library provides noisy point clouds. A statistical outlier removal filter is usually needed to obtain clearer point clouds.

{\bfseries S\+E\+T\+\_\+\+W\+R\+I\+T\+E} ~\newline
format\+: \mbox{[}set write param\mbox{]} ~\newline
action\+: param can be set to on or off. If it is set to on, the current point cloud is saved in the path specified in the config file.

{\bfseries B\+L\+O\+C\+K} ~\newline
format\+: \mbox{[}block param\mbox{]} ~\newline
action\+: param can be set to right or left. It is useful if it is wanted to force the i\+Cub to use a specific arm. The arm can be unblocked using the command U\+N\+B\+L\+O\+C\+K.

{\bfseries U\+N\+B\+L\+O\+C\+K} ~\newline
format\+: \mbox{[}unblock param\mbox{]} ~\newline
action\+: param can be set to right or left. It serves to unblock an arm that was previously blocked using the command B\+L\+O\+C\+K.

{\bfseries G\+R\+A\+S\+P} ~\newline
format\+: \mbox{[}grasp (x y)\mbox{]} \char`\"{}wait\char`\"{} ~\newline
action\+: the algorithm runs to find a good triplet and a good configuration, then sends such configuration to the actions\+Rendering\+Engine module, which executes the grasp. If the optional parameter wait is present, the grasp is computed and sent to matlab, but it is not executed. If then the user wants to execute the grasp, he has to use the command G\+O. Otherwise, to reset the computation, he can use the command D\+O\+N\+T.

{\bfseries G\+O} ~\newline
format\+: \mbox{[}go\mbox{]} ~\newline
action\+: if the computation of the grasp was successful but the grasp has not been executed yet because the wait command has been added to G\+R\+A\+S\+P, go makes the robot execute the grasp.

{\bfseries D\+O\+N\+T} ~\newline
format\+: \mbox{[}dont\mbox{]} ~\newline
action\+: it resets all the information that has been previously computed. It is usually used when a grasp (x y) wait command has been sent, and the computed grasp is not satisfactory.

{\bfseries I\+S\+G\+R\+A\+S\+P\+E\+D} ~\newline
format\+: \mbox{[}is\+Grasped\mbox{]} ~\newline
action\+: returns A\+C\+K if the grasp has been successfully executed by A\+R\+E, otherwise returns N\+A\+C\+K.\hypertarget{group__handIKModule_lib_sec}{}\subsection{Libraries}\label{group__handIKModule_lib_sec}

\begin{DoxyItemize}
\item Y\+A\+R\+P libraries.
\item objects3\+D library
\item \hyperlink{group__minimumBoundingBox}{minimum\+Bounding\+Box} library
\item \hyperlink{group__forceClosure}{force\+Closure} library
\item Open\+C\+V library
\item Point Cloud Library.
\end{DoxyItemize}\hypertarget{group__handIKModule_portsc_sec}{}\subsection{Ports Created}\label{group__handIKModule_portsc_sec}

\begin{DoxyItemize}
\item {\itshape /} $<$mod\+Name$>$/rpc remote procedure call. It always replies something.
\item {\itshape /} $<$mod\+Name$>$/are/cmd\+:o this is the port through which end-\/effector position and orientation are commanded to A\+R\+E to execute the grasp.
\item {\itshape /} $<$mod\+Name$>$/to\+Matlab port that allows sending the hand configuration to some matlab scripts, that then depict the position of the hand over the object.
\item {\itshape /} $<$mod\+Name$>$/ik1r\+:o /$<$mod\+Name$>$/ik2r\+:o /$<$mod\+Name$>$/ik3r\+:o /$<$mod\+Name$>$/ik4r\+:o the ports that communicate with the inverse kinematics module for the right hand.
\item {\itshape /} $<$mod\+Name$>$/ik1l\+:o /$<$mod\+Name$>$/ik2l\+:o /$<$mod\+Name$>$/ik3l\+:o /$<$mod\+Name$>$/ik4l\+:o the ports that communicate with the inverse kinematics module for the left hand.
\item {\itshape /} $<$mod\+Name$>$/mesh\+:i this is the port where the module reads the point cloud.
\item {\itshape /} $<$mod\+Name$>$/reconstruction the module sends to this port a pixel belonging to the object to be segmented and reconstructed.
\item {\itshape /} $<$mod\+Name$>$/depth2kin\+:o this is the port that asks depth2kin the 3\+D point computed taking into account the errors between the arm and the eye.
\end{DoxyItemize}\hypertarget{group__handIKModule_parameters_sec}{}\subsection{Parameters}\label{group__handIKModule_parameters_sec}
The following are the options that are usually contained in the configuration file\+:

--name {\itshape name} 
\begin{DoxyItemize}
\item specify the module name, which is {\itshape precision-\/grasp} by default.
\end{DoxyItemize}

--robot {\itshape robot} 
\begin{DoxyItemize}
\item specify the robot that has to be used. It is icub by default.
\end{DoxyItemize}

-- radius\+Search {\itshape radius\+Search} 
\begin{DoxyItemize}
\item double representing the area of the neighborhood to be searched to compute surface normals. It is usually set to the area of the robot's palm.
\end{DoxyItemize}

-- path {\itshape path} 
\begin{DoxyItemize}
\item in case the user wants to run the algorithm in simulation using an already reconstructed 3\+D point cloud, he can put a .ply file representing such cloud in the path directory.
\end{DoxyItemize}

-- from\+File {\itshape from\+File} 
\begin{DoxyItemize}
\item if this parameter is set to true, the algorithm runs in simulation using a .ply file that contains the point cloud to be evaluated, which is in the \char`\"{}path\char`\"{} dir.
\end{DoxyItemize}

-- x {\itshape x} 
\begin{DoxyItemize}
\item x position of the window that depicts the point cloud.
\end{DoxyItemize}

-- y {\itshape y} 
\begin{DoxyItemize}
\item y position of the window that depicts the point cloud.
\end{DoxyItemize}

-- w {\itshape w} 
\begin{DoxyItemize}
\item width of the window that depicts the point cloud.
\end{DoxyItemize}

-- h {\itshape h} 
\begin{DoxyItemize}
\item height of the window that depicts the point cloud.
\end{DoxyItemize}

-- output\+File {\itshape output\+File} 
\begin{DoxyItemize}
\item the folder where point clouds will be saved.
\end{DoxyItemize}

-- limit\+\_\+finger\+\_\+max {\itshape limit\+\_\+finger\+\_\+max} 
\begin{DoxyItemize}
\item maximum distance between two fingers. Set to 0.\+08 by default.
\end{DoxyItemize}

-- limit\+\_\+finger\+\_\+min {\itshape limit\+\_\+finger\+\_\+min} 
\begin{DoxyItemize}
\item minimum distance between two fingers. Set to 0.\+02 by default.
\end{DoxyItemize}

-- sampling {\itshape sampling} 
\begin{DoxyItemize}
\item parameter to sample the point cloud through a voxel grid.
\end{DoxyItemize}

-- alpha {\itshape alpha} 
\begin{DoxyItemize}
\item friction coefficient.
\end{DoxyItemize}

-- phi\+\_\+p {\itshape phi\+\_\+p} 
\begin{DoxyItemize}
\item parameter for particle swarm optimization related to the best position reached from a particle over time.
\end{DoxyItemize}

-- phi\+\_\+g {\itshape phi\+\_\+g} 
\begin{DoxyItemize}
\item parameter for particle swarm optimization related to the best position ever reached from the particles.
\end{DoxyItemize}

-- iterations {\itshape iterations} 
\begin{DoxyItemize}
\item number of iterations for particle swarm optimization.
\end{DoxyItemize}

-- hand\+\_\+area {\itshape hand\+\_\+area} 
\begin{DoxyItemize}
\item maximum area covered by thumb, index and middle fingers.
\end{DoxyItemize}\hypertarget{group__handIKModule_tested_os_sec}{}\subsection{Tested O\+S}\label{group__handIKModule_tested_os_sec}
Windows, Linux

\begin{DoxyAuthor}{Author}
Ilaria Gori 
\end{DoxyAuthor}
